
# مشروع تشخيص أمراض القلب باستخدام التعلم العميق

## 1. نظرة عامة على المشروع

يهدف هذا المشروع إلى تطوير نموذج للتنبؤ وتشخيص بأمراض القلب باستخدام تقنيات التعلم العميق. يعتمد المشروع على مجموعة بيانات تحتوي على معلومات طبية لمجموعة من المرضى، ويتم استخدام هذه البيانات لتدريب نموذج قادر على التنبؤ بإصابة المريض بمرض القلب بناءً على السمات المتاحة.

## 2. البيانات المستخدمة

- **المصدر:** مجموعة بيانات عامة من https://www.kaggle.com/datasets/redwankarimsony/heart-disease-data  تحتوي على معلومات طبية لعدد من المرضى.
- **السمات:** تتضمن البيانات سمات مثل العمر، الجنس، ضغط الدم، مستوى الكوليسترول، معدل ضربات القلب القصوى، وغيرها.

## 3.المتطلبات المستخدمه في المشروع 
-اللغة البرمجية: Python
-الأطر والتقنيات:
*مكتبات التعلم الآلي: scikit-learn, TensorFlow, Keras,
*تحليل البيانات الطبية وتصويرها: Pandas, NumPy, matplotlib and seaborn
*بناء الـ API: إطار العمل flask 

## 4. شرح تفصيلي للأكواد والنتائج

### الخطوة 1: تحميل البيانات واستعراضها

```python
import pandas as pd 
heart_data = pd.read_csv('heart_disease_uci.csv')
heart_data.head()
```

- **الشرح:** يتم هنا تحميل البيانات من ملف CSV باستخدام مكتبة `pandas`. يتم عرض أول خمس صفوف من البيانات باستخدام `head()` للتحقق من الشكل العام للبيانات والتأكد من تحميلها بشكل صحيح.

### الخطوة 2: عرض معلومات البيانات الأساسية

```python
heart_data.info()
```

- **الشرح:** يتم استخدام دالة `info()` لعرض ملخص عن البيانات، بما في ذلك عدد القيم غير المفقودة في كل عمود، وأنواع البيانات. يساعد هذا في فهم هيكل البيانات وتحديد الأعمدة التي قد تتطلب معالجة إضافية.

### الخطوة 3: التعامل مع القيم المفقودة

```python
# احذف الصفوف التي تحتوي على قيم مفقودة
data_dropna = heart_data.dropna()

#استبدال القيم المفقودة بمتوسط العمود (للأعمدة العددية)
heart_data['trestbps'].fillna(heart_data['trestbps'].mean(), inplace=True)
heart_data['chol'].fillna(heart_data['chol'].mean(), inplace=True)
heart_data['thalch'].fillna(heart_data['thalch'].mean(), inplace=True)
heart_data['oldpeak'].fillna(heart_data['oldpeak'].mean(), inplace=True)
heart_data['ca'].fillna(heart_data['ca'].mean(), inplace=True)

#استبدال القيم المفقودة بأكثر القيم تكرارًا (للأعمدة الفئوية)
heart_data['fbs'].fillna(heart_data['fbs'].mode()[0], inplace=True)
heart_data['restecg'].fillna(heart_data['restecg'].mode()[0], inplace=True)
heart_data['exang'].fillna(heart_data['exang'].mode()[0], inplace=True)
heart_data['slope'].fillna(heart_data['slope'].mode()[0], inplace=True)
heart_data['thal'].fillna(heart_data['thal'].mode()[0], inplace=True)
```

- **الشرح:** يتم أولاً عرض عدد القيم المفقودة في كل عمود باستخدام `isnull().sum()`. بعد ذلك، يتم التعامل مع القيم المفقودة بطريقتين:
  - **حذف الصفوف:** يمكن حذف الصفوف التي تحتوي على أي قيم مفقودة باستخدام `dropna()`، مما يضمن عدم وجود بيانات ناقصة.
  - **استبدال القيم المفقودة:** يمكن استبدال القيم المفقودة في الأعمدة العددية بمتوسط القيم في العمود باستخدام `fillna()`، مما يساعد في الحفاظ على البيانات سليمة وملائمة للنماذج ونفس طريقه مع الاعمده الفئويه فقط استبدالها باكثر القيم تكرارا

### الخطوة 4: حذف الأعمدة غير المهمة

```python
# حذف الاعمده الغير المهمه 

# حذف الأعمدة
columns_to_drop = ['id','dataset']
heart_data = heart_data.drop(columns=columns_to_drop)

# عرض البيانات بعد حذف الأعمدة للتأكد
print("الأعمدة بعد الحذف:")
print(heart_data.head())
```
الهدف: إزالة الأعمدة التي لا تساهم في التحليل أو بناء النموذج.
التفاصيل التقنية:
drop(): يحذف الأعمدة المحددة من DataFrame. العمود 'id' لا يحتوي على معلومات مفيدة للتحليل، والعمود 'dataset' قد لا يكون له تأثير على النتيجة.



### الخطوة 5: التحقق من القيم غير المنطقية

```python
# التحقق من وجود قيم غير منطقية أو سالبة
invalid_values = {}

# التحقق من الأعمدة التي يجب أن تكون فيها القيم إيجابية
columns_positive = ['age', 'trestbps', 'chol', 'thalch', 'oldpeak', 'ca']
for column in columns_positive:
    if any(heart_data[column] < 0):
        invalid_values[column] = heart_data[heart_data[column] < 0]
# 2. التحقق من القيم الفئوية للتأكد من عدم وجود تناقضات أو أخطاء إملائية
categorical_columns = ['sex', 'cp','restecg','exang','thal']
for column in categorical_columns:
    print(f"القيم الفريدة في العمود '{column}':")
    print(heart_data[column].unique())
    print("\n---------------------------\n")

if invalid_values:
    print("تم العثور على قيم غير منطقية أو سالبة:")
    for column, values in invalid_values.items():
        print(f"القيم غير المنطقية في العمود '{column}':")
        print(values)
else:
    print("لم يتم العثور على قيم غير منطقية أو سالبة في الأعمدة المحددة.")

# التعامل مع القيم السالبة

#استبدال القيم السالبة بصفر
heart_data['oldpeak'] = heart_data['oldpeak'].apply(lambda x: 0 if x < 0 else x)
# التحقق من النتيجة النهائية
print("\nتحقق من القيم الفريدة في العمود 'oldpeak' بعد المعالجة:")
print(heart_data['oldpeak'].unique())
```

- **الشرح:** يتم التحقق من الأعمدة التي يجب أن تحتوي على قيم موجبة فقط، مثل العمر، ضغط الدم، وغيرها. إذا كانت هناك قيم سالبة، يتم تخزينها في متغير `invalid_values` للتحليل اللاحق وكذالك يتم تحقق في قيم الفئويه للتاكد من عدم وجود تناقضات او اخطاء املائيه 
- **الهدف من حذف القيم السالبة:** القيم السالبة في العمود `oldpeak` غير منطقية، حيث أن هذا العمود يمثل قيمة فيزيائية لا يمكن أن تكون سالبة. حذف هذه القيم يساعد في تحسين جودة البيانات وضمان دقة النموذج.
- ### شرح اكثر
- •	من الناحية الطبية: oldpeak يمثل انخفاض مستوى ST في رسم القلب الكهربائي، وهو مؤشر على نقص تروية القلب. القيم السالبة لهذا المؤشر غير منطقية من الناحية الطبية، لذا فإن وجود قيم سالبة قد يشير إلى أخطاء في البيانات أو قياسات غير صحيحة.
	•	تحسين جودة البيانات: من خلال حذف القيم السالبة، نضمن أن البيانات تعكس حالات طبية واقعية وتكون أكثر موثوقية للتحليل.
وقمت باستبدال  القيم السالبة بصفر. هذه الخطوة قد تكون منطقية لانه اعتقد أن القيم السالبة هي أخطاء إدخال.


#### ملاحظه : لا املك خبره مسبقه في تحليل بيانات طبيه لذالك قمت في البحث عن معلومات عن الاعمده 


### تحويل عمود 'num' إلى فئات 0 و 1 فقط
# 0:مريض قلب :1 , غير مريض قلب 
```python
# 2. تحويل عمود 'num' إلى فئات 0 و 1 فقط
# 0:مريض قلب :1 , غير مريض قلب 
heart_data['num'] = heart_data['num'].apply(lambda x: 1 if x > 0 else 0)
```
- **الشرح:** يحتوي العمود على درجه مرض القلب من واحد الى اربعه وتعني مريض وصفر تعني غير مريض لذالك قمت بتبسيط وتحويله الى تصنيف ثنائي الصفر تعني غير مريض والواحد تعني مريض


### الخطوة 7: تحليل البيانات لاكتشاف الأنماط والعلاقات بين الأعراض والأمراض وتمثيلها مرئيا
- **الشرح:** في بدايه نقوم باستدعاء المكتبات الرسم مطلوبه مثل matplotlib وseaborn ثم كتابه اكواد لرسم العلاقات 


#### 1 - توزيع العمر بالنسبة لتشخيص أمراض القلب  
```python
# ضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))

# رسم مخطط بياني لتوزيع العمر باستخدام بيانات heart_data
# x يحدد المحور الأفقي (العمر)
# hue يحدد التصنيف اللوني بناءً على العمود 'num' الذي يمثل التشخيص القلبي
# multiple='stack' يعني تكديس الأشرطة فوق بعضها
# kde=True يضيف منحنى الكثافة Kernel Density Estimation
sns.histplot(data=heart_data, x='age', hue='num', multiple='stack', kde=True)

# إضافة عنوان للرسم البياني
plt.title('Age distribution by cardiac diagnosis')

# تسمية المحور الأفقي
plt.xlabel('age')

# تسمية المحور العمودي
plt.ylabel('Number of cases')

# عرض الرسم البياني
plt.show()
```
##### تحليل الرسم البياني 

الرسم البياني الذي تم إنشاؤه هو رسم بياني متعدد الألوان يظهر توزيع العمر بين المرضى بناءً على وجود أو عدم وجود مرض قلبي.

- ماذا يمكن أن نستنتج من الرسم البياني؟

توزيع الأعمار لكل فئة تشخيصية:
سيظهر الرسم البياني كيف يتم توزيع الأعمار بين المرضى الذين تم تشخيصهم بمرض قلبي والذين لم يتم تشخيصهم.

على سبيل المثال، إذا كانت هناك كثافة أعلى من المرضى الذين لديهم مرض قلبي في الفئة العمرية 50-60 عامًا مقارنة بفئة 30-40 عامًا، فهذا يمكن أن يشير إلى أن الخطر يزيد مع التقدم في العمر.

- نمط التوزيع:
من خلال النظر إلى منحنى تقدير الكثافة (KDE)، يمكن ملاحظة كيف يتوزع العمر عبر جميع الفئات بشكل أكثر سلاسة.
يمكن تحديد الأنماط، مثل الذروة في حالات المرض القلبي في أعمار معينة.

- الفئات العمرية الأكثر عرضة:
يمكن للرسم البياني أن يظهر الفئات العمرية الأكثر عرضة للمرض القلبي، مما يوفر معلومات قيمة للأطباء والعاملين في مجال الرعاية الصحية لتوجيه جهود الوقاية والتوعية.

- كيف هي العلاقة بين العمر والتشخيص القلبي؟
  
الاتجاهات الواضحة: إذا كان هناك تداخل قليل بين الفئات المختلفة، فهذا قد يعني أن العمر عامل قوي في تحديد وجود المرض القلبي.

الكثافة العالية في الأعمار المتقدمة: إذا كانت الأشرطة مكدسة بشكل أكبر في الفئات العمرية المتقدمة، فهذا يدل على أن المرض القلبي يصبح أكثر شيوعاً مع تقدم العمر.

- الخلاصه 
الرسم البياني  يقدم نظرة بصرية شاملة لتوزيع الأعمار بين المرضى بناءً على التشخيص القلبي. يساعد في تحديد الفئات العمرية الأكثر عرضة للإصابة بالمرض، ويقدم معلومات قيمة للمهنيين في الرعاية الصحية لتطوير استراتيجيات وقائية. 


#### 2. العلاقة بين ضغط الدم الانقباضي (trestbps) والكوليسترول (chol) وتشخيص أمراض القلب
```python
# استيراد مكتبة arabic_reshaper لإعادة تشكيل النصوص العربية
import arabic_reshaper

# استيراد دالة get_display من مكتبة bidi لتصحيح اتجاه النص العربي
from bidi.algorithm import get_display

# تجهيز النصوص باللغة العربية عن طريق إعادة تشكيل النص وتصحيح اتجاهه
title_text = get_display(arabic_reshaper.reshape('العلاقة بين ضغط الدم الانقباضي والكوليسترول وتشخيص أمراض القلب'))
xlabel_text = get_display(arabic_reshaper.reshape('ضغط الدم الانقباضي (mmHg)'))
ylabel_text = get_display(arabic_reshaper.reshape('الكوليسترول (mg/dL)'))

# إعداد البيانات وضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))

# رسم مخطط بياني نقطي يوضح العلاقة بين ضغط الدم الانقباضي والكوليسترول
# x يحدد المحور الأفقي (ضغط الدم الانقباضي)
# y يحدد المحور العمودي (الكوليسترول)
# hue يحدد التصنيف اللوني بناءً على التشخيص القلبي (العمود 'num')
# palette='coolwarm' لتحديد الألوان المستخدمة في المخطط
sns.scatterplot(data=heart_data, x='trestbps', y='chol', hue='num', palette='coolwarm')

# إضافة العناوين باللغة العربية للمخطط والمحاور
plt.title(title_text, fontsize=14)
plt.xlabel(xlabel_text, fontsize=12)
plt.ylabel(ylabel_text, fontsize=12)

# عرض المخطط البياني
plt.show()
```
##### تحليل الرسم البياني 

الرسم البياني الذي تم إنشاؤه هنا هو مخطط نقطي  يعرض العلاقة بين ضغط الدم الانقباضي  و مستويات الكوليسترول  في المرضى، مع تصنيف الحالات حسب التشخيص القلبي .

- ماذا يمكن أن نستنتج من الرسم البياني؟

العلاقة بين ضغط الدم الانقباضي والكوليسترول:
يمكن ملاحظة كيف تتوزع القيم المتعلقة بضغط الدم الانقباضي والكوليسترول بين المرضى. على سبيل المثال، إذا كان هناك اتجاه معين (مثل زيادة مستويات الكوليسترول مع ارتفاع ضغط الدم)، فإن ذلك يشير إلى علاقة إيجابية بين المتغيرين.

- تصنيف الحالات حسب التشخيص القلبي:
باستخدام التصنيف اللوني بناءً على التشخيص القلبي، يمكن تحديد المرضى الذين لديهم أمراض قلبية من خلال لون معين. يساعد ذلك في رؤية الاختلافات بين المرضى المصابين وغير المصابين

- فهم توزيع البيانات:
بالنظر إلى توزيع النقاط، يمكن تحديد ما إذا كانت هناك تجمعات من البيانات أو اتجاهات واضحة. هذا يمكن أن يساعد في تحديد ما إذا كانت هناك عوامل معينة (مثل ارتفاع الكوليسترول) ترتبط بشكل كبير بضغط الدم أو بوجود مرض قلبي.

- العلاقة بين المتغيرات:
إذا كانت هناك تجمعات من النقاط في جزء معين من الرسم البياني، فقد يشير ذلك إلى وجود علاقة أو نمط بين ضغط الدم والكوليسترول في تلك الفئة.
إذا كان هناك اختلافات لونية واضحة بين مجموعات التشخيص (مثل اختلاف في مستوى ضغط الدم أو الكوليسترول بين المرضى المصابين وغير المصابين)، فهذا يمكن أن يكون مؤشرًا على أهمية هذه العوامل في التشخيص القلبي.

- الملخص
الرسم البياني يوفر وسيلة مرئية لفهم العلاقة بين ضغط الدم الانقباضي والكوليسترول وتشخيص أمراض القلب، مما يمكن الأطباء من تحديد الأنماط والعلاقات التي قد تكون ذات صلة في التشخيص والعلاج.


#### 3. العلاقة بين الحد الأقصى لمعدل ضربات القلب (thalch) وتشخيص أمراض القلب
```python
# استيراد مكتبة arabic_reshaper لإعادة تشكيل النصوص العربية
import arabic_reshaper

# استيراد دالة get_display من مكتبة bidi لتصحيح اتجاه النص العربي
from bidi.algorithm import get_display

# تجهيز النصوص باللغة العربية عن طريق إعادة تشكيل النص وتصحيح اتجاهه
title_text = get_display(arabic_reshaper.reshape('العلاقة بين الحد الأقصى لمعدل ضربات القلب وتشخيص أمراض القلب'))
xlabel_text = get_display(arabic_reshaper.reshape('تشخيص أمراض القلب'))
ylabel_text = get_display(arabic_reshaper.reshape('الحد الأقصى لمعدل ضربات القلب'))

# إعداد البيانات وضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))


# x يحدد المحور الأفقي (تشخيص أمراض القلب)
# y يحدد المحور العمودي (الحد الأقصى لمعدل ضربات القلب)
# palette='Set3' لتحديد الألوان المستخدمة في المخطط من لوحة الألوان Set3
sns.boxplot(data=heart_data, x='num', y='thalch', palette='Set3')

# إضافة العناوين باللغة العربية للمخطط والمحاور
plt.title(title_text, fontsize=14)
plt.xlabel(xlabel_text, fontsize=12)
plt.ylabel(ylabel_text, fontsize=12)

# عرض المخطط البياني
plt.show()
```
##### تحليل الرسم البياني 

الرسم البياني الذي تم إنشاؤه هو مخطط الصندوق ، والذي يعرض العلاقة بين تشخيص أمراض و الحد الأقصى لمعدل ضربات القلب .

- ماذا يمكن أن نستنتج من الرسم البياني؟

توزيع الحد الأقصى لمعدل ضربات القلب لكل تشخيص:
يظهر الرسم البياني توزيع الحد الأقصى لمعدل ضربات القلب للمرضى الذين لديهم تشخيص ت مختلفة لأمراض القلب. يمكن ملاحظة القيم المتوسطة والانحرافات بين التشخيصات المختلفة.

- اختلافات بين الفئات:
باستخدام المخطط الصندوق، يمكن رؤية كيفية اختلاف الحد الأقصى لمعدل ضربات القلب بين المرضى الذين لديهم أمراض قلبية والذين ليس لديهم. يوفر هذا فهمًا أفضل لكيفية تأثير التشخيص القلبي على معدل ضربات القلب.

- الاستنتاجات الممكنة من الرسم البياني:
مقارنة الحد الأقصى لمعدل ضربات القلب بين التشخيصات: يمكن أن تكشف مقارنة الصناديق المختلفة عن وجود اختلافات كبيرة في معدل ضربات القلب الأقصى بين المرضى الذين تم تشخيصهم بأمراض قلبية مختلفة أو عدمها.

رؤية القيم الشاذة : قد تظهر بعض القيم الشاذة، وهي نقاط بيانات تقع بعيدًا عن باقي البيانات، مما قد يشير إلى حالات غير اعتيادية أو بيانات متطرفة.

- الخلاصه 
الرسم البياني يساعد على فهم كيف يختلف الحد الأقصى لمعدل ضربات القلب بين المرضى الذين يعانون من أمراض قلبية وأولئك الذين لا يعانون منها. يمكن أن يكون هذا مفيدًا للأطباء لتقييم مخاطر أمراض القلب بناءً على معدل ضربات القلب.


#### 4. العلاقة بين العمر ونوع ألم الصدر (Scatter Plot)
```python
# ضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))

# رسم مخطط بياني نقطي يوضح العلاقة بين العمر ونوع آلام الصدر
# x يحدد المحور الأفقي (العمر)
# y يحدد المحور العمودي (نوع آلام الصدر)
# hue يحدد التصنيف اللوني بناءً على حالة مرض القلب (العمود 'num')
# palette='muted' لتحديد الألوان المستخدمة في المخطط بتدرجات ة
sns.scatterplot(data=heart_data, x='age', y='cp', hue='num', palette='muted')

# إضافة عنوان للرسم البياني
plt.title('Age vs Chest Pain Type by Heart Disease Status')

# تسمية المحور الأفقي
plt.xlabel('Age')

# تسمية المحور العمودي
plt.ylabel('Chest Pain Type')

# عرض المخطط البياني
plt.show()
```
##### تحليل الرسم البياني 

الرسم البياني الذي تم إنشاؤه هو مخطط نقطي  يعرض العلاقة بين العمر  و نوع آلام الصدر ، مع تصنيف البيانات بناءً على حالة مرض القلب .

- ماذا يمكن أن نستنتج من الرسم البياني؟

- العلاقة بين العمر ونوع آلام الصدر:
يظهر كيف تتوزع أنواع آلام الصدر بين مختلف الأعمار. يمكن تحديد الفئات العمرية التي تعاني من أنواع معينة من آلام الصدر.

- تصنيف الحالات حسب حالة مرض القلب:
باستخدام التصنيف اللوني ، يتم تمييز المرضى بناءً على حالة مرض القلب، مما يساعد في رؤية الأنماط المرتبطة بوجود أو عدم وجود مرض القلب بين الأعمار المختلفة وأنواع آلام الصدر.

- الاستنتاجات الممكنة من الرسم البياني:
مقارنة الأنماط بين الفئات العمرية: يمكن ملاحظة الأنماط والفروق بين المرضى من مختلف الأعمار الذين يعانون من أنواع مختلفة من آلام الصدر، وربط ذلك بحالة مرض القلب.

التعرف على الفئات الأكثر عرضة: يمكن أن يساعد الرسم البياني في تحديد الفئات العمرية التي تعاني من أنواع معينة من آلام الصدر والتي ترتبط بحالات مرض القلب، مما يمكن أن يكون مفيدًا للأطباء في التشخيص والعلاج.

- الخلاصة
هذا الرسم البياني يوفر رؤية بصرية عن العلاقة بين العمر ونوع آلام الصدر وحالة مرض القلب، مما يمكن الأطباء والباحثين من فهم الأنماط والتوزيعات بشكل أفضل لتوجيه استراتيجيات الوقاية والعلاج.


#### 5. توزيع الكوليسترول بناءً على تشخيص أمراض القلب
```python
# ضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))
# x يحدد المحور الأفقي (مستوى الكوليسترول)
# hue يحدد التصنيف اللوني بناءً على التشخيص القلبي (العمود 'num')
# fill=True لملء المساحة تحت منحنى الكثافة
# palette='coolwarm' لتحديد الألوان المستخدمة في المخطط ئ
sns.kdeplot(data=heart_data, x='chol', hue='num', fill=True, palette='coolwarm')

# إضافة عنوان للرسم البياني
plt.title('Distribution of cholesterol based on the diagnosis of heart disease')

# تسمية المحور الأفقي
plt.xlabel('Cholesterol level')

# تسمية المحور العمودي
plt.ylabel('Density')

# عرض المخطط البياني
plt.show()
```
##### تحليل الرسم البياني 
الرسم البياني الذي تم إنشاؤه هو مخطط كثافة  يعرض توزيع مستوى الكوليسترول  بين المرضى، مع تصنيف البيانات بناءً على التشخيص القلبي .

- ماذا يمكن أن نستنتج من الرسم البياني؟

توزيع مستويات الكوليسترول:
يظهر كيف تتوزع مستويات الكوليسترول بين المرضى. المنحنيات المملوءة تظهر الكثافة المتوقعة للكوليسترول في مجموعات المرضى المختلفة.

- تصنيف الحالات حسب التشخيص القلبي:
باستخدام التصنيف اللوني  بناءً على التشخيص القلبي، يمكن تحديد المرضى الذين لديهم أمراض قلبية من خلال لون معين. يساعد ذلك في رؤية الاختلافات في توزيع الكوليسترول بين المرضى المصابين وغير المصابين بأمراض قلبية.

- الاستنتاجات الممكنة من الرسم البياني:
مقارنة توزيع الكوليسترول بين المرضى: يتيح الرسم البياني رؤية كيفية اختلاف توزيع الكوليسترول بين المرضى بناءً على حالة مرض القلب، مما قد يشير إلى وجود علاقة بين مستوى الكوليسترول واحتمالية الإصابة بمرض قلبي.

تحديد الفئات ذات الكثافة العالية: يمكن أن يساعد في تحديد مستويات الكوليسترول التي تكون أكثر شيوعاً بين المرضى المصابين بمرض قلبي مقارنة بغير المصابين، مما يمكن أن يكون مفيدًا في التقييم الطبي.

- الخلاصة
الرسم البياني يوفر فهماً بصرياً لتوزيع مستويات الكوليسترول بين المرضى وتصنيفهم حسب وجود مرض قلبي، مما يساعد الأطباء والباحثين في تحليل الأنماط وتحديد العلاقات المحتملة بين الكوليسترول وأمراض القلب.


#### 6. العلاقة بين العمر والحد الأقصى لمعدل ضربات القلب مع تشخيص أمراض القلب
```python
# ضبط حجم الشكل البياني بعرض 10 وارتفاع 6
plt.figure(figsize=(10, 6))

# x يحدد المحور الأفقي (العمر)
# y يحدد المحور العمودي (الحد الأقصى لمعدل ضربات القلب)
# hue يحدد التصنيف اللوني بناءً على تشخيص أمراض القلب (العمود 'num')
# palette='muted' لتحديد الألوان المستخدمة في المخططة
sns.lineplot(data=heart_data, x='age', y='thalch', hue='num', palette='muted')

# إضافة عنوان للرسم البياني
plt.title('Relationship between Age and Maximum Heart Rate (thalach) with Heart Disease Diagnosis')

# تسمية المحور الأفقي
plt.xlabel('Age')

# تسمية المحور العمودي
plt.ylabel('Maximum Heart Rate (thalach)')

# عرض المخطط البياني
plt.show()
```
##### تحليل الرسم البياني 
الرسم البياني الذي تم إنشاؤه هو مخطط خطي  يعرض العلاقة بين العمر  و الحد الأقصى لمعدل ضربات القلب ، مع تصنيف البيانات بناءً على تشخيص أمراض القلب .

- ماذا يمكن أن نستنتج من الرسم البياني؟

العلاقة بين العمر والحد الأقصى لمعدل ضربات القلب:
يظهر الرسم البياني كيف يتغير الحد الأقصى لمعدل ضربات القلب مع تقدم العمر. يمكن ملاحظة الاتجاهات العامة لزيادة أو انخفاض معدل ضربات القلب الأقصى عبر الأعمار المختلفة.

- تصنيف الحالات حسب تشخيص أمراض القلب:
باستخدام التصنيف اللوني  بناءً على تشخيص أمراض القلب، يمكن تحديد الاختلافات في العلاقة بين العمر ومعدل ضربات القلب الأقصى بين المرضى المصابين بأمراض القلب وغير المصابين.

- الاستنتاجات الممكنة من الرسم البياني:
رؤية الاتجاهات العامة: يساعد الرسم البياني في تحديد ما إذا كان هناك ارتباط بين العمر ومعدل ضربات القلب الأقصى، وكيف يختلف هذا الارتباط بناءً على وجود مرض قلبي.

فهم الفروق بين المرضى: يمكن أن يساعد في مقارنة الفروق في معدل ضربات القلب الأقصى بين المرضى المصابين وغير المصابين بأمراض القلب ضمن فئات عمرية مختلفة.

- الخلاصة
هذا الرسم البياني يوفر فهماً بصرياً لكيفية تأثير العمر على الحد الأقصى لمعدل ضربات القلب وكيفية اختلاف هذه العلاقة بناءً على تشخيص أمراض القلب، مما يمكن أن يكون مفيدًا للأطباء في تقييم حالة القلب للمرضى بناءً على العمر ومعدل ضربات القلب.

#### ملاحظه 
لم استطع حل مشكله مصفوفه الترابط وقد جربت العديد من حلول منها تعديل حجم المخطط والون وتاكد من الاعمده ومراجعه مشاريع التي قمت بها سابقا لذالك قمت بحذفها والاكتفاء ب 6 مخططات 


### الخطوة 7: تحويل القيم الفئوية باستخدام الترميز

```python
from sklearn.preprocessing import LabelEncoder

# إنشاء كائن LabelEncoder لكل عمود
label_encoder_sex = LabelEncoder()
label_encoder_exang = LabelEncoder()
label_encoder_fbs = LabelEncoder()
label_encoder_cp = LabelEncoder()
label_encoder_restecg = LabelEncoder()
label_encoder_thal= LabelEncoder()
label_encoder_slope= LabelEncoder()

# ترميز العمود "sex"
heart_data['sex'] = label_encoder_sex.fit_transform(heart_data['sex'])
# ترميز العمود "exang"
heart_data['exang'] = label_encoder_exang.fit_transform(heart_data['exang'])
# ترميز العمود "fbs"
heart_data['fbs'] = label_encoder_exang.fit_transform(heart_data['fbs'])
# ترميز العمود "cp"
data['cp'] = label_encoder_cp.fit_transform(data['cp'])
# ترميز العمود "restecg"
data['restecg'] = label_encoder_restecg.fit_transform(data['restecg'])
# ترميز العمود "thal"
data['thal'] = label_encoder_thal.fit_transform(data['thal'])
# ترميز العمود "thal"
data['slope'] = label_encoder_thal.fit_transform(data['slope'])
```
- **الشرح:** يتم استخدام `LabelEncoder` لتحويل القيم الفئوية إلى قيم عددية، وهو أمر 
ضروري لتدريب نماذج التعلم العميق التي تتطلب مدخلات عددية.


### الخطوة 8:التأكد من قيم عمود الخرج 
```python
# حساب عدد القيم الفريدة في العمود 'num' وتكرارها
value_counts = heart_data['num'].value_counts()

# عرض النتيجة
value_counts

# استيراد مكتبة matplotlib لرسم المخططات البيانية
import matplotlib.pyplot as plt

# تعيين المتغير labels ليساوي الفهرس (index) من سلسلة value_counts
labels = value_counts.index

# تعيين المتغير counts ليساوي القيم (values) من سلسلة value_counts
counts = value_counts.values

# رسم مخطط دائري باستخدام القيم (counts) والتسميات (labels)
# autopct='%1.1f%%' يعرض النسبة المئوية لكل قطعة في المخطط بترميز عشري واحد
plt.pie(counts, labels=labels, autopct='%1.1f%%')

# إضافة عنوان للمخطط الدائري
plt.title('Distribution of Exited')

# عرض المخطط
plt.show()
```
- **الشرح:** اقوم بتحقق من توازن القيم وان لايوجد فرق كبير بينهم وعرض مخطط الدائري يقوم باستعراض النسب بين القيمتين لانه لو كان هناك فرق كبير في الاصناف  مثلا 85% و15% فذالك يوثر على اداء النموذج ويجب معالجتها لتكون متوازنه

### الخطوة 9: تقسيم البيانات وتحضيرها للنماذج

```python
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

X = heart_data.drop('num', axis=1)# عمود الدخل 
y = heart_data['num']# عمود الخرج

# تقسيم البيانات إلى مجموعتي تدريب واختبار
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

# تقيس البيانات
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
```
- **1الشرح:** y يمثل التصنيف أو النتيجة التي نحاول التنبؤ بها (في هذه الحالة، تشخيص أمراض القلب).
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0):

يتم تقسيم البيانات إلى مجموعتين: تدريب (X_train, y_train) واختبار (X_test, y_test).
train_test_split(X, y, random_state=0) يقوم بتقسيم مجموعة البيانات X و y عشوائيًا إلى مجموعات التدريب والاختبار.

- **2الشرح:**random_state=0 يضمن أن التقسيم يكون قابلاً للتكرار في كل مرة يتم فيها تشغيل الكود.
يتم إنشاء كائن StandardScaler، وهو أداة تستخدم لتوحيد البيانات بحيث يكون لكل ميزة نفس متوسط القيم والانحراف المعياري (عادةً متوسط=0 وانحراف معياري=1).
هذه الخطوة ضرورية لتحسين أداء نماذج التعلم الآلي التي تكون حساسة للمدى المطلق للبيانات


- **3الشرح:** يتم تقسيم البيانات إلى مجموعتي تدريب واختبار باستخدام `train_test_split` لضمان التقييم العادل للنموذج. ثم يتم تقيس البيانات باستخدام `StandardScaler` لتوحيد نطاق القيم، مما يساعد في تحسين أداء النموذج.

### الخطوة 10: بناء وتدريب نموذج الشبكة العصبية

```python
# استيراد المكتبات اللازمة من Keras لبناء نموذج الشبكة العصبية
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping

# إنشاء نموذج تسلسلي Sequential
model = Sequential([
    # إضافة طبقة Dense (طبقة كاملة الترابط) مع 130 وحدة عصبية، باستخدام دالة تنشيط 'relu'
    # input_dim=X_train.shape[1] يشير إلى عدد الميزات في بيانات التدريب
    # kernel_regularizer='l2' يضيف تنظيم L2 لمنع النموذج من الإفراط في التكيف (overfitting)
    Dense(130, input_dim=X_train.shape[1], activation='relu', kernel_regularizer='l2'),
    
    # إضافة طبقة إسقاط (Dropout) بنسبة 40%، وهي تقنية لتقليل الإفراط في التكيف عن طريق تعطيل بعض الوحدات العصبية بشكل عشوائي أثناء التدريب
    Dropout(0.4),
    
    # إضافة طبقة Dense ثانية مع 64 وحدة عصبية ودالة تنشيط 'relu'
    Dense(64, activation='relu'),
    
    # إضافة طبقة إسقاط ثانية بنسبة 40%
    Dropout(0.4),
    
    # إضافة طبقة Dense ثالثة مع 32 وحدة عصبية ودالة تنشيط 'relu'
    Dense(32, activation='relu'),
    
    # إضافة طبقة الإخراج Dense مع وحدة عصبية واحدة ودالة تنشيط 'sigmoid'
    # دالة التنشيط 'sigmoid' تستخدم للحصول على احتمالية بين 0 و 1، مما يناسب مشاكل التصنيف الثنائي
    Dense(1, activation='sigmoid')
])

# تجميع النموذج (compile) مع تحديد المحسن (optimizer)،دالة الخساره د (loss function)، والمعايير التي ستستخدم لمتابعة الأداء (metrics)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# إعداد وظيفة الإيقاف المبكر (EarlyStopping) لمراقبة أداء النموذج أثناء التدريب
# patience=10 يعني إيقاف التدريب إذا لم يتحسن الأداء بعد 10 فترات متتالية
early_stopping = EarlyStopping(patience=10)

# تدريب النموذج على بيانات التدريب
# epochs=60 يشير إلى عدد الدورات الكاملة على بيانات التدريب
# batch_size=32  حجم الدفعه يحدد عدد العينات التي سيتم معالجتها قبل تحديث النموذج 
# validation_data=(X_test, y_test) تستخدم لمراقبة الأداء على مجموعة الاختبار في كل فترة (epoch)
# callbacks=[early_stopping] يشير إلى استخدام الإيقاف المبكر خلال التدريب
history = model.fit(X_train, y_train, epochs=60, batch_size=32, validation_data=(X_test, y_test), callbacks=[early_stopping])
```
- **الشرح:** استخدمت داله التنشيطsigmoid و داله الخساره binary_crossentropy لتلائم نموذج تصنيف ثنائي 0,1

- **الشرح:** يتم هنا بناء نموذج شبكة عصبية باستخدام مكتبة `Keras`. يحتوي النموذج على طبقات متعددة، ويتم إضافة طبقات إسقاط (Dropout) لتقليل الإفراط في التعلم. يتم استخدام `EarlyStopping` لإيقاف التدريب إذا لم يكن هناك تحسن في الأداء بعد عدد معين من الفترات.




### الخطوة 11: تقييم النموذج

```python
# استيراد المقاييس اللازمة لتقييم أداء النموذج من مكتبة sklearn
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# استخدام النموذج المدرب للتنبؤ على بيانات الاختبار
y_pred = model.predict(X_test)

# تحويل التنبؤات الاحتمالية إلى قيم ثنائية (0 أو 1)
# إذا كانت النتيجة أكبر من 0.5 يتم تصنيفها كـ 1 (إيجابية)، وإلا تصنف كـ 0 (سلبية)
y_pred_binary = (y_pred > 0.5)

#حساب صحة (accuracy) من خلال مقارنة القيم الحقيقية بالتنبؤات الثنائية
accuracy = accuracy_score(y_test, y_pred_binary)

# حساب الدقة الإيجابية (precision)، التي تقيس نسبة التنبؤات الإيجابية الصحيحة من جميع التنبؤات الإيجابية
precision = precision_score(y_test, y_pred_binary)

#حساب الاستذكار ء (recall)، الذي يقيس نسبة التنبؤات الإيجابية الصحيحة من جميع الحالات الإيجابية الفعلية
recall = recall_score(y_test, y_pred_binary)

# حساب مقياس F1، وهو المتوسط التوافقي بين الدقة والاستذكار، ويعطي فكرة عن الأداء العام للنموذج
f1 = f1_score(y_test, y_pred_binary)

# طباعة النتائج
print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1)
```
- **1الشرح:** 
يتم حساب الدقة (accuracy)، التي تقيس نسبة التنبؤات الصحيحة (الإيجابية والسلبية) من جميع التنبؤات.
يتم حساب الدقة الإيجابية (precision)، وهي نسبة الحالات الإيجابية الصحيحة من بين جميع الحالات التي توقع النموذج أنها إيجابية.
يتم حساب الاستذكار ء (recall)، وهو نسبة الحالات الإيجابية الصحيحة من جميع الحالات الإيجابية الفعلية.
يتم حساب مقياس F1، وهو مقياس يجمع بين الدقة والاستدعاء، ويعطي تقييمًا شاملاً لأداء النموذج.

- **2الشرح:** يتم هنا تقييم أداء النموذج باستخدام عدة مقاييس مثل الدقة، الدقة الإيجابية، الاستذكار، وF1 Score. هذه المقاييس توفر فهمًا أفضل لأداء النموذج وتساعد في تحديد المجالات التي قد تحتاج إلى تحسين.

### رسم مخطط للتحقق 
```python
# رسم المخطط للتحقق 

# رسم منحنى الدقة على بيانات التدريب
plt.plot(history.history['accuracy'], label='Training Accuracy')

# رسم منحنى الدقة على بيانات التحقق (validation)
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')

# إضافة عنوان للمخطط
plt.title('Model Accuracy')

# تسمية المحور العمودي (y-axis)
plt.ylabel('Accuracy')

# تسمية المحور الأفقي (x-axis)
plt.xlabel('Epoch')

# إضافة وسيلة إيضاح (legend) لتمييز منحنيات التدريب والتحقق
plt.legend(loc='upper left')

# عرض المخطط
plt.show()
```
- **1الشرح:** بعد تنفيذ هذا الكود، سيتم عرض مخطط يظهر تطور دقة النموذج (accuracy) على بيانات التدريب وبيانات التحقق (validation) عبر كل فترة تدريبية.
يساعد هذا المخطط في تقييم كيفية أداء النموذج بمرور الوقت، مما يمكن أن يكشف عن أي مشاكل مثل فرط التخصيص ف (overfitting) إذا كانت دقة التحقق تتناقص أو تستقر بينما دقة التدريب تستمر في التحسن.

### الخطوة 12: حفظ النموذج واستخدامه للتنبؤ

```python
from tensorflow.keras.models import load_model
# حفظ النموذج
model.save("project_1.keras")

# استخدام النموذج المدرب للتنبؤ على بيانات جديدة
model = load_model('project_1.keras')

# إدخال بيانات جديدة من المستخدم، ترميزها وتقييسها، ثم التنبؤ بها باستخدام النموذج
```

- **الشرح:** يتم حفظ النموذج المدرب لاستخدامه لاحقًا، ويمكن تحميل النموذج لاحقًا للتنبؤ ببيانات جديدة.

### الخطوة 13 :انشاء واجهه برمجيه (API)
#### لقد قمت بحفظ الاكواد المستخدمه في ملف اسمه app.py

##### استدعاء المكتبات الازمه 1
```python
from flask import Flask, request, jsonify
import pandas as pd
from sklearn.preprocessing import LabelEncoder, StandardScaler
from tensorflow.keras.models import load_model
```
- **الشرح:**Flask: إطار عمل لبناء تطبيقات الويب في بايثون.
request و jsonify: لاستقبال الطلبات وإرسال الردود بصيغة JSON.
pandas: للتعامل مع البيانات في شكل DataFrame.
LabelEncoder و StandardScaler: لمعالجة البيانات الفئوية وتقييس البيانات الرقمية.
load_model: لتحميل نموذج تعلم عميق تم تدريبه مسبقًا.

##### 2. إنشاء تطبيق Flask
```python
app = Flask(__name__)
```
##### 3. تحميل النموذج المدرب
```python
model = load_model('project_1.keras')
```
- **الشرح:**يتم هنا تحميل النموذج المدرب من ملف (project_1.keras) لاستخدامه في التنبؤ.


###### 4. ترميز الأعمدة الفئوية 
```python
label_encoders = {
    'sex': LabelEncoder(),
    'cp': LabelEncoder(),
    'restecg': LabelEncoder(),
    'exang': LabelEncoder()
}
label_encoders['sex'].fit(['male', 'female'])
label_encoders['cp'].fit(['typical angina', 'atypical angina', 'non-anginal pain', 'asymptomatic'])
label_encoders['restecg'].fit(['normal', 'ST-T wave abnormality', 'left ventricular hypertrophy'])
label_encoders['exang'].fit(['yes', 'no'])
```
- **الشرح:**LabelEncoder(): يقوم بتحويل القيم الفئوية النصية إلى أرقام يمكن للنموذج فهمها.
يتم إنشاء ترميز لكل من الأعمدة الفئوية: الجنس (sex)، نوع ألم الصدر (cp)، تخطيط القلب أثناء الراحة (restecg)، وجود الذبحة الصدرية (exang).

##### 5 تقييس البيانات (Standardization)
```python
scaler = StandardScaler()
```
- **الشرح:**StandardScaler(): يستخدم لتقييس البيانات بحيث يكون لها متوسط 0 وانحراف معياري 1. هذا يساعد النموذج على التعامل بشكل أفضل مع البيانات.

###### 6. نقطة النهاية للتنبؤ (/predict)
```python
@app.route('/predict', methods=['POST'])
def predict():
    # الحصول على بيانات المريض من الطلب
    data = request.json
    
    # تحويل بيانات المريض إلى DataFrame
    df = pd.DataFrame([data])

    # ترميز القيم الفئوية
    for column in label_encoders.keys():
        df[column] = label_encoders[column].transform(df[column])

    # تقيسس البيانات
    df_scaled = scaler.fit_transform(df)

    # التنبؤ باستخدام النموذج
    prediction = model.predict(df_scaled)
    result = (prediction[0] > 0.5).astype(int)

    # عرض النتيجة
    diagnosis = "من المحتمل أن يكون المريض مصاباً بمرض القلب" if result == 1 else "من غير المحتمل أن يكون المريض مصاباً بمرض القلب"
    return jsonify({"diagnosis": diagnosis, "probability": float(prediction[0])})
```
- **1الشرح:** @app.route('/predict', methods=['POST']): يحدد نقطة النهاية (endpoint) /predict التي تقبل طلبات POST.
data = request.json: يستقبل بيانات المريض بصيغة JSON.
pd.DataFrame([data]): تحويل البيانات إلى DataFrame لتسهيل المعالجة.
df[column] = label_encoders[column].transform(df[column]): تحويل القيم الفئوية إلى أرقام.
df_scaled = scaler.fit_transform(df): تقييس البيانات
- **2الشرح:**prediction = model.predict(df_scaled): استخدام النموذج لتنبؤ إذا كان المريض مصابًا بمرض القلب.
result = (prediction[0] > 0.5).astype(int): تحويل النتيجة إلى 0 أو 1 بناءً على احتمال الإصابة
diagnosis: صياغة نتيجة التشخيص بناءً على النتيجة.
jsonify(): تحويل الرد إلى JSON وإرساله للمستخدم

##### 8. تشغيل التطبيق
```python
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```
- **الشرح:**app.run(host='0.0.0.0', port=5000): يشغل التطبيق على host و port المحددين. host='0.0.0.0' يعني أن التطبيق متاح على جميع الواجهات الشبكية، وport=5000 هو المنفذ الذي سيتم تشغيل التطبيق عليه.

- **الهدف:**الهدف من هذا التطبيق هو توفير واجهة برمجية تفاعلية تمكّن مقدمي الرعاية الصحية من إدخال بيانات المرضى واسترجاع تشخيصات مبنية على نموذج تعلم عميق مدرب. يساعد هذا التطبيق في تسهيل عملية التشخيص واتخاذ القرارات ة.

## كيفية تشغيل المشروع

### المتطلبات الأساسية

لتشغيل المشروع، يجب التأكد من تثبيت المكتبات التالية:
- `pandas`
- `scikit-learn`
- `tensorflow`
- `flask`
- `matplotlib`
- `seaborn`

### شرح

1. **تحميل البيانات:** يجب أن يكون ملف البيانات `heart_disease_uci.csv` متاحًا في نفس المجلد الذي يحتوي على ملفات الكود.
2. **تنفيذ الأوامر:** استخدم بيئة برمجية مثل Jupyter Notebook أو أي محرر يدعم Python لتنفيذ الأوامر خطوة بخطوة.
3. **إدخال بيانات جديدة:** بعد تدريب النموذج، يمكن استخدامه للتنبؤ ببيانات جديدة من خلال إدخال السمات الطبية للمريض في النموذج المدرب.

### الأوامر لتثبيت المكتبات:

يمكن تثبيت المكتبات باستخدام الأمر التالي في بيئة Python:
```
pip install pandas scikit-learn tensorflow flask matplotlib seaborn
```
## طريقه استخدام API

### تشغيل خادم Flask 

##### الخطوه الاولى 
خطوات تشغيل خادم Flask:
فتح نافذة سطر الأوامر (Terminal):

على Windows: يمكنك استخدام PowerShell أو موجه الأوامر (Command Prompt).
على macOS/Linux: استخدم Terminal.
واذهب الى المجلد الذي يحتوي على ملف اسمه app.py 
###### الخطوه الثانيه 
تشغيل الخادم: اكتب الأمر التالي في سطر الأوامر لتشغيل الـAPI:
```
python app.py
```
إذا كان كل شيء صحيحًا، سترى رسائل تشير إلى أن التطبيق يعمل على http://127.0.0.1:5000/

##### الخطوه الثالثه 
 إرسال طلب POST باستخدام cURL
الآن بعد أن أصبح خادم Flask يعمل، يمكنك استخدام cURL لإرسال طلب POST لاختبار الـAPI.

خطوات استخدام cURL:
افتح نافذة جديدة من سطر الأوامر (Terminal): في هذه النافذة الجديدة، ستقوم بإدخال أوامر cURL.

كتابة أمر cURL: أدخل الأمر التالي لإرسال طلب POST إلى الـAPI
```
curl -X POST http://127.0.0.1:5000/predict -H "Content-Type: application/json" -d '{
    "age": 45,
    "sex": "male",
    "cp": "typical angina",
    "trestbps": 130,
    "chol": 250,
    "fbs": 0,
    "restecg": "normal",
    "thalach": 180,
    "exang": "no",
    "oldpeak": 1.0,
    "slope": 2,
    "ca": 0,
    "thal": 3
}'

```
##### واذا كنت تستخدم  موجه الأوامر (Command Prompt) في Windows
```
curl -X POST http://127.0.0.1:5000/predict -H "Content-Type: application/json" -d "{\"age\": 45, \"sex\": \"male\", \"cp\": \"typical angina\", \"trestbps\": 130, \"chol\": 250, \"fbs\": 0, \"restecg\": \"normal\", \"thalach\": 180, \"exang\": \"no\", \"oldpeak\": 1.0, \"slope\": 2, \"ca\": 0, \"thal\": 3}"

```
#### النتيجه سوفه تحصل على رد
. الرد سيكون بصيغة JSON، على سبيل المثال
```
{
    "diagnosis": "من المحتمل أن يكون المريض مصاباً بمرض القلب"
}

```
# نهايه المشروع 
